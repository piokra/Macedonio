/*
 * Macedon.io
 *
 * Macedon.io API
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package macedonio

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

const (
	TOKEN    = "token"
	USERNAME = "username"
)

func CreateUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	var user User

	body, err := ioutil.ReadAll(r.Body)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusUnprocessableEntity)
		return
	}

	err = json.Unmarshal(body, &user)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusUnprocessableEntity)
		return
	}

	var salt [64]byte
	_, err = rand.Read(salt[:])

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	saltedPassword := append(salt[:], []byte(user.Password)...)
	hash, err := bcrypt.GenerateFromPassword(saltedPassword, bcrypt.DefaultCost)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	dbUser := DBUser{
		Username:           user.Username,
		Email:              user.Email,
		Salt:               salt[:64],
		SaltedPasswordHash: hash,
	}

	if err = GetDBHandle().Create(&dbUser).Error; err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusNotAcceptable)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func CreateUsersWithArrayInput(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusNotImplemented)
}

func CreateUsersWithListInput(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusNotImplemented)
}

func DeleteUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	cookies := ExtractCookies(r.Cookies())

	token, ok := cookies[TOKEN]

	if !ok {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	dbUser, err := TokenToUser(token.Value)

	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		log.Printf("failed to get user by token. reason: %v\n", err)
		return
	}

	username := r.URL.Query().Get(USERNAME)

	if username == "" || username != dbUser.Username {
		w.WriteHeader(http.StatusUnauthorized)
		log.Printf("unauthorized deletion attempt. user requested: %s. actual: %s", username, dbUser.Username)
		return
	}

	GetDBHandle().Delete(&dbUser)

	w.WriteHeader(http.StatusOK)
}

func ExtractCookies(cookies []*http.Cookie) map[string]*http.Cookie {
	ans := make(map[string]*http.Cookie)

	for _, cookie := range cookies {
		if cookie != nil {
			ans[cookie.Name] = cookie
		}
	}
	return ans
}

func GetUserByName(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	username := r.URL.Query().Get(USERNAME)

	var dbUser DBUser

	if err := GetDBHandle().Where("username = ?", username).First(&dbUser).Error; err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusNotAcceptable)
		return
	}

	cookies := ExtractCookies(r.Cookies())
	token := cookies[TOKEN]

	tokenUser, err := TokenToUser(token.Value)

	if err != nil {
		tokenUser = DBUser{Username: ""}
	}

	var user User

	user.Username = username
	if tokenUser.Username == username {
		user.Email = tokenUser.Email
		user.Id = int64(tokenUser.ID)
	}

	data, err := json.Marshal(&user)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	if c, err := w.Write(data); c != len(data) || err != nil {
		log.Println(c, err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func LoginUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	body, err := ioutil.ReadAll(r.Body)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusUnprocessableEntity)
		return
	}

	type LoginData struct {
		Username string
		Password string
	}
	var loginData LoginData

	err = json.Unmarshal(body, &loginData)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusUnprocessableEntity)
		return
	}

	var dbUser DBUser
	if GetDBHandle().First(&dbUser, "username = ?", loginData.Username).RecordNotFound() {
		log.Printf("User not found: %s.\n", loginData.Username)
		w.WriteHeader(http.StatusNotFound)
		return
	}
	var saltedPassword []byte
	saltedPassword = append(saltedPassword, dbUser.Salt...)
	saltedPassword = append(saltedPassword, []byte(loginData.Password)...)
	if err := bcrypt.CompareHashAndPassword(dbUser.SaltedPasswordHash, saltedPassword); err != nil {
		log.Printf("Invalid password for user: %s\n", loginData.Username)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	expiresAt := time.Now().Add(time.Hour * 24)

	u, err := uuid.NewRandom()
	if err != nil {
		log.Printf("UUID failed for user: %s. Err: %v\n", loginData.Username, err)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	token, err := u.MarshalBinary()

	if err != nil {
		log.Printf("UUID failed for user: %s. Err: %v\n", loginData.Username, err)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	dbToken := DBUserToken{
		DBUser:    dbUser,
		Scope:     "all",
		ExpiresAt: expiresAt,
	}
	dbToken.Token = append(dbToken.Token, token...)

	if err = GetDBHandle().Create(&dbToken).Error; err != nil {
		log.Printf("Failed to create token for user: %s. Err: %v", loginData.Username, err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	cookie := http.Cookie{
		Name:    TOKEN,
		Value:   base64.StdEncoding.EncodeToString(token),
		Expires: expiresAt,
		Secure:  true,
	}

	http.SetCookie(w, &cookie)
	w.WriteHeader(http.StatusOK)
}

func LogoutUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	cookies := ExtractCookies(r.Cookies())
	token, ok := cookies[TOKEN]

	if !ok {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	dbToken, err := TokenToDBToken(token.Value)

	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	err = GetDBHandle().Delete(&dbToken).Error

	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func UpdateUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	var user User

	data, err := ioutil.ReadAll(r.Body)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusNotAcceptable)
		return
	}

	err = json.Unmarshal(data, &user)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusNotAcceptable)
		return
	}

	cookies := ExtractCookies(r.Cookies())
	token, ok := cookies[TOKEN]

	if !ok {
		log.Println(err)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	dbUser, err := TokenToUser(token.Value)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	db := GetDBHandle()
	db.Begin()

	if user.Password != "" {
		var salt [64]byte
		_, err = rand.Read(salt[:])

		if err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		saltedPassword := append(salt[:], []byte(user.Password)...)

		hash, err := bcrypt.GenerateFromPassword(saltedPassword, bcrypt.DefaultCost)

		if err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		dbUser.SaltedPasswordHash = hash
		dbUser.Salt = salt[:]
	}
	if user.Username != "" {
		dbUser.Username = user.Username
	}
	if user.Email != "" {
		dbUser.Email = user.Email
	}

	if err := db.Save(&dbUser).Error; err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusNotAcceptable)
		db.Rollback()
		return
	}

	if err := db.Model(&dbUser).Related(&dbUser.Tokens).Error; err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		db.Rollback()
		return
	}

	for _, token := range dbUser.Tokens {
		if err := db.Delete(&token).Error; err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusInternalServerError)
			db.Rollback()
			return
		}
	}

	db.Commit()
	w.WriteHeader(http.StatusOK)
}
