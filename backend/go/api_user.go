/*
 * Macedon.io
 *
 * Macedon.io API
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package macedonio

import (
	"crypto/rand"
	"encoding/json"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

func CreateUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	var user User

	defer r.Body.Close()
	body, err := ioutil.ReadAll(r.Body)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusUnprocessableEntity)
		return
	}

	err = json.Unmarshal(body, &user)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusUnprocessableEntity)
		return
	}

	var salt [64]byte
	_, err = rand.Read(salt[:])

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	saltedPassword := append(salt[:], []byte(user.Password)...)
	hash, err := bcrypt.GenerateFromPassword(saltedPassword, bcrypt.DefaultCost)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	dbUser := DBUser{
		Username:           user.Username,
		Email:              user.Email,
		Salt:               salt[:64],
		SaltedPasswordHash: hash,
	}

	if err = GetDBHandle().Create(&dbUser).Error; err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusNotAcceptable)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func CreateUsersWithArrayInput(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func CreateUsersWithListInput(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func DeleteUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func GetUserByName(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func LoginUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	defer r.Body.Close()
	body, err := ioutil.ReadAll(r.Body)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusUnprocessableEntity)
		return
	}

	type LoginData struct {
		Username string
		Password string
	}
	var loginData LoginData

	err = json.Unmarshal(body, &loginData)

	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusUnprocessableEntity)
		return
	}

	var dbUser DBUser
	if GetDBHandle().First(&dbUser, "username = ?", loginData.Username).RecordNotFound() {
		log.Printf("User not found: %s.\n", loginData.Username)
		w.WriteHeader(http.StatusNotFound)
		return
	}
	var saltedPassword []byte
	saltedPassword = append(saltedPassword, dbUser.Salt...)
	saltedPassword = append(saltedPassword, []byte(loginData.Password)...)
	if err := bcrypt.CompareHashAndPassword(dbUser.SaltedPasswordHash, saltedPassword); err != nil {
		log.Printf("Invalid password for user: %s\n", loginData.Username)
		w.WriteHeader(http.StatusForbidden)
		return
	}

	expiresAt := time.Now().Add(time.Hour * 24)

	u, err := uuid.NewRandom()
	if err != nil {
		log.Printf("UUID failed for user: %s. Err: %v\n", loginData.Username, err)
		w.WriteHeader(http.StatusForbidden)
		return
	}

	token, err := u.MarshalBinary()

	if err != nil {
		log.Printf("UUID failed for user: %s. Err: %v\n", loginData.Username, err)
		w.WriteHeader(http.StatusForbidden)
		return
	}

	dbToken := DBUserToken{
		DBUser:    dbUser,
		Scope:     "all",
		ExpiresAt: expiresAt,
	}
	copy(dbToken.Token[:], token)

	if err = GetDBHandle().Create(&dbToken).Error; err != nil {
		log.Printf("Failed to create token for user: %s. Err: %v", loginData.Username, err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	tokenJson, err := json.Marshal(&dbToken)
	if err != nil {
		log.Printf("Failed to marshal json for user: %s. Err: %v", loginData.Username, err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.Write(tokenJson)

	w.WriteHeader(http.StatusOK)
}

func LogoutUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func UpdateUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}
